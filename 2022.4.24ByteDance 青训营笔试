字节青训营进阶版笔试
1.RDBMS：Relational Database Managemnt System 关系型数据库管理系统
2.解决哈希冲突方法：
  (1) 开放定址法
    从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。
    在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。
    开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素
      2.1.1 线行探查法
      线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查
      完全部单元为止。

      2.1.2 平方探查法
        平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。
        在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。

      2.1.3 双散列函数探查法
      这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素
      的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其
      探查序列的步长值是同一关键字的另一散列函数的值。
   (2) 链地址法（拉链法）
      链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行
      插入和删除的情况。
   (3) 再哈希法
      就是同时构造多个不同的哈希函数：
      Hi = RHi(key)   i= 1,2,3 … k;
      当H1 = RH1(key)  发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。
   (4) 建立公共溢出区
      将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。
3.各种排序算法的细节，包括时间复杂度，是否稳定等等
  希尔排序：
    有一个N个数的数列：
      先取一个小于N的整数d1，将位置是d1整数倍的数们分成一组，对这些数进行直接插入排序。
      接着取一个小于d1的整数d2，将位置是d2整数倍的数们分成一组，对这些数进行直接插入排序。
      接着取一个小于d2的整数d3，将位置是d3整数倍的数们分成一组，对这些数进行直接插入排序。
      ...
      直到取到的整数d=1，接着使用直接插入排序。
      在最好情况下，也就是数列是有序时，希尔排序需要进行logn次增量的直接插入排序，因为每次直接插入排序最佳时间复杂度都为：O(n)，因此希尔排序的最佳时间复杂度为：O(nlogn)。
      希尔排序最坏时间复杂度为O(n^2)。
      希尔排序是不稳定的，因为每一轮分组，都使用了直接插入排序，但分组会跨越n个位置，导致两个相同的数，发现不了对方而产生了顺序变化。
      // 增量序列折半的希尔排序
func ShellSort(list []int) {
    // 数组长度
    n := len(list)

    // 每次减半，直到步长为 1
    for step := n / 2; step >= 1; step /= 2 {
        // 开始插入排序，每一轮的步长为 step
        for i := step; i < n; i += step {
            for j := i - step; j >= 0; j -= step {
                // 满足插入那么交换元素
                if list[j+step] < list[j] {
                    list[j], list[j+step] = list[j+step], list[j]
                    continue
                }
                break
            }
        }
    }
}
4.线程同步有哪些方式？
  为什么需要线程同步：
    线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。
    因此需要线程的同步，多个线程按顺序访问资源。

互斥量 Mutex：
  互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；
  当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；
信号量 Semaphore：
  信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
  信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，
  只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。
  线程处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；
事件 Event：
  允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。
  手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。
  自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。
临界区 Critical Section：
   任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。
互斥量和临界区有什么区别？
  互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。
5.cpu cache问题
https://blog.51cto.com/u_14888059/3787298
6.红黑树性质
 插入节点最多需要旋转几次？
  旋转3次
 所有叶子节点都是黑色
 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点
 根节点是黑色
 每个红色节点必须有两个黑色的子节点
 从根到叶子的最长可能路径不多于最短的可能路径的二倍长。
7.go语言GC
  Go语言的GC，内存自动回收，再也不需要开发人员管理内存。GC过程是：先stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来。
  接着立即start the world，恢复服务。同时起一个专门gorountine，回收内存到空闲list中以备复用，不物理释放，物理释放由专门线程定期来执行。
  GC瓶颈在于每次都要扫描所有对象来判活，待收集的对象数目越多，速度越慢，GC性能可能随着版本不断更新会不断优化。
8.两道算法题 
    第一道是dfs 已ac 大约20min
    第二道类似https://leetcode-cn.com/problems/restore-ip-addresses/ 时间不够没写完
  
