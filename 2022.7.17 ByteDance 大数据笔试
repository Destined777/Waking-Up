## 列式存储 
        即将单列数据保存到一起，不同列分开保存。
        优点：
        1. 适合分布式存储，可以完全利用并发读入和并发写入的能力
        2. 同一列数据的数据类型相同，更好压缩
        3. 同一列放在一起排序更方便，where某一列更快
        相较而言，行存储更容易实现事务性，一致性控制
        hbase可以看作是基于列式存储的非关系型数据库
        parquet是基于列式存储定义的一种文件格式
## LSM树
  LSM树，即日志结构合并树(Log-Structured Merge-Tree)。 其实它并不属于一个具体的数据结构，它更多是一种数据结构的设计思想。 大多NoSQL数据库核心思想都是基于LSM来做的， 
只是具体的实现不同。
  它的核心思路其实非常简单，就是假定内存足够大，因此不需要每次有数据更新就必须将数据写入到磁盘中， 而可以先将最新的数据驻留在内存中，等到积累到最后多之后，
再使用归并排序的方式将内存内的数据合并追加到磁盘队尾 (因为所有待排序的树都是有序的，可以通过合并排序的方式快速合并到一起)。

  LSM具有批量特性，存储延迟。当写读比例很大的时候（写比读多），LSM树相比于B树有更好的性能。因为随着insert操作，为了维护B树结构，节点分裂。 
读磁盘的随机读写概率会变大，性能会逐渐减弱。 多次单页随机写，变成一次多页随机写,复用了磁盘寻道时间，极大提升效率。

  LSM Tree弄了很多个小的有序结构，比如每m个数据，在内存里排序一次，下面100个数据，再排序一次……这样依次做下去，我就可以获得N/m个有序的小的有序结构。

  在查询的时候，因为不知道这个数据到底是在哪里，所以就从最新的一个小的有序结构里做二分查找，找得到就返回，找不到就继续找下一个小有序结构，一直到找到为止。 
很容易可以看出，这样的模式，读取的时间复杂度是(N/m)*log2N 。读取效率是会下降的。

  当然也可以做一些优化

  Bloom filter: 就是个带随即概率的bitmap,可以快速的告诉你，某一个小的有序结构里有没有指定的那个数据的。于是就可以不用二分查找，
而只需简单的计算几次就能知道数据是否在某个小集合里啦。效率得到了提升，但付出的是空间代价。
  compact:小树合并为大树:因为小树他性能有问题，所以要有个进程不断地将小树合并到大树上，这样大部分的老数据查询也可以直接使用log2N的方式找到，
不需要再进行(N/m)*log2n的查询了
## 简答题
自己好友的TOP10推荐共同好友（类似qq的推荐好友功能）存储与实现
## 算法题
一道贪心 共n排座位，给出间距，m排不坐人，求如何让最小间距最大
一道dfs
