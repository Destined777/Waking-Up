## 2023.7.21 上午 tplink一面 腾讯会议 纯聊天 没做题 问的问题基本都答出来了 共20min 没让反问
## 2023.7.21 下午 作业帮一面 牛客 自我介绍后算法 旋转数组找最小值 边界条件那里顿了10min 大数据量找top100  分布式锁  mongodb相关 读写双删  go 的channel interface底层
## 2023.7.26 下午 tplink二面 腾讯会议 
高并发的优化  
分布式系统的扩展性通常分为水平扩展性和垂直扩展性两种。
水平扩展性
水平扩展性是指通过增加系统的节点数量来提高系统的性能和容量。水平扩展性通常需要使用分布式架构和负载均衡技术，将请求分发到多个节点上进行处理。水平扩展性可以提高系统的可靠性和可用性，因为当某个节点出现故障时，其他节点可以接替其工作。

负载均衡技术：一致性哈希，轮询算法（Round Robin）最少连接算法（Least Connections）IP哈希算法（IP Hash）加权轮询算法（Weighted Round Robin）

垂直扩展性
垂直扩展性是指通过增加单个节点的计算能力和存储容量来提高系统的性能和容量。垂直扩展性通常需要使用更高性能的硬件设备，例如更快的CPU、更大的内存和更快的存储设备。垂直扩展性可以提高系统的性能和容量，但成本较高，且存在单点故障的风险。

需要注意的是，水平扩展性和垂直扩展性并不是互斥的，而是可以结合使用。在实际应用中，可以根据实际需求和成本考虑采用何种扩展方式，以提高系统的性能、容量和可靠性。
redis的并发如何实现的 做题 剑指 Offer II 085. 生成匹配的括号（not done）
## 2023.7.28 上午 作业帮二面 
更多倾向于腾讯实习时期的项目，问题基本都答上来了，问了一下分布式锁的实现 做题是go实现了一个并发
一个好的分布式锁常常需要以下特性:
可重入
同一时间点,只有一个线程持有锁
容错性, 当锁节点宕机时, 能及时释放锁
高性能
无单点问题
## 2023.7.28 下午 百度一面
问题基本都答上来了 问了下B+树 问了下数据库连接池的实现 算法题是  5. 最长回文子串 做出来了 但有点慢
要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：

能在尽可能少的磁盘的 I/O 操作中完成查询工作；
要能高效地查询某一个记录，也要能高效地执行范围查找；
由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（假设一个节点的大小「小于」操作系统的最小读写单位块的大小），也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。
因为 B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助
因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。

连接池：
一个连接，从创建完毕到销毁，期间只被使用了一次（这里的一次是指在单个作用域内的使用），当周期结束，另外一个调用者仍然需要这个连接去做事，就要重复去经历这种生命周期。因为创建和销毁都是需要对应的服务消耗时间以及系统资源去处理的，这样不仅浪费了大量的系统资源，而且导致业务响应过程中都要花费部分时间去重复的创建和销毁，得不偿失，而连接池便被赋予了解决这种问题的使命
保存连接的容器是必不可少的，另外，该容器也要支持连接的添加和移除功能，并保证线程安全。
我们需要因为要对连接的销毁做逻辑调整，我们需要重写它的close以及isClosed方法。
我们需要有个入口对连接池做管理，例如回收空闲连接。
另外，我们可以将连接池拆分为3个类型：

工作池：存放正在被使用的连接。
空闲池：存放空闲连接。
回收池：已经被回收（物理关闭）的连接。
## 2023.8.1 上午 tplink 三面 聊项目
## 2023.8.1 下午 字节抖音音乐 一面
深挖腾讯实习项目 45min左右 算法题 最近公共祖先
两个问题没答上来： 
1. 一致性哈希是为了解决什么问题，与哈希算法有什么区别？
哈希有一个很致命的问题，如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据，否则会出现查询不到数据的问题。
一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致哈希算法是对 2^32 进行取模运算，是一个固定的值。
首先，对 key 进行哈希计算，确定此 key 在环上的位置；
然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。
在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。
但是一致性哈希算法并不保证节点能够在哈希环上分布均匀，这样就会带来一个问题，会有大量的请求集中在一个节点上。
一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题。
不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。
当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高。
比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。
而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。
2. mongodb 的 id生成规则
3. 之前我们使用MySQL等关系型数据库时，主键都是设置成自增的。但在分布式环境下，这种方法就不可行了，会产生冲突。为此，MongoDB采用了一个称之为ObjectId的类型来做主键。ObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，依次代表：

4字节：UNIX时间戳
3字节：表示运行MongoDB的机器
2字节：表示生成此_id的进程
3字节：由一个随机数开始的计数器生成的值
在MongoDB中，对单个文档的操作是原子的。由于可以在单个文档结构中使用内嵌文档和数组来获得数据之间的关系，而不必跨多个文档和集合进行范式化，所以这种单文档原子性避免了许多实际场景中对多文档事务的需求。
对于那些需要对多个文档（在单个或多个集合中）进行原子性读写的场景，MongoDB支持多文档事务。而使用分布式事务，事务可以跨多个操作、集合、数据库、文档和分片使用。
## 2023.8.3 下午 百度二面 聊项目+一道算法第k大的数
## 2023.8.8 米哈游一面 问了几个c++ 不会 
快排，堆排 不稳定 归并 稳定
硬软链接的区别
软链接以存放另一个文件的路径的形式存在，硬链接以文件副本的形式存在；
软链接可以跨不同的文件系统而链接，硬链接不可以；
软链接可以对目录进行链接，而硬链接不可以；
软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。
删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接就变成了死链接。删除硬链接的话，只要索引节点的个数不为零，则不会对原始文件造成任何影响；
注意：不论是硬链接或软链接都不会将原本的目标文件完全复制一份，而只会占用非常少量的存储空间。
算法：LRU, 随机打乱数组
## 2023.8.8 下午 字节二面 
一道新的算法 判断字符串c是不是a,b的交错
雪花算法 
一个Snowflake ID有64位元。前41位是时间戳，表示了自选定的时期以来的毫秒数。 接下来的10位代表计算机ID，防止冲突。 其余12位代表每台机器上生成ID的序列号，这允许在同一毫秒内创建多个Snowflake ID。最后以十进制将数字序列化
SnowflakeID基于时间生成，故可以按时间排序。此外，一个ID的生成时间可以由其自身推断出来，反之亦然。该特性可以用于按时间筛选ID，以及与之联系的对象。
## 2023.8.10 下午 元戎启行 一面
聊项目+简单go八股+一道新题（dp）
问到了GMP模型没有P会怎样：
- 创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。
- M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。
- 系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。
## 2023.8.15 下午 滴滴 一面
go gc 对map的优化 
在 Go 语言中，map 是一种非常常见的数据结构，它被广泛地用于存储键值对。在 map 的使用中，尤其是在大量的数据处理场景下，会经常涉及到垃圾回收（GC）的问题，特别是对于大规模的 map 数据结构，其 GC 的开销可能会对程序的性能产生较大的影响。

以下是一些优化 map 的 GC 的方法：

预分配：在创建 map 的时候，可以预先指定 map 的大小，这样可以减少 map 的扩容次数，从而减少 GC 的负担。需要注意的是，map 的大小并不是越大越好，过大的 map 可能会占用过多的内存。

减少 map 的生命周期：如果 map 的生命周期可以被限制在一个较小的范围内，可以减少 GC 的开销。例如，在函数内部创建一个 map，在函数结束后 map 就会被销毁，这样就可以避免在 map 的生命周期结束后进行垃圾回收。

复用 map：在某些场景下，可以将同一个 map 多次使用，这样可以减少创建和销毁 map 的次数，从而减少 GC 的负担。

避免在 map 中存储指针类型：由于 map 的实现方式会导致它的键和值会被移动，如果 map 中存储的是指针类型，可能会导致指针失效。如果需要在 map 中存储指针类型，可以考虑使用 sync.Map。

避免在 map 中存储大量数据：如果需要存储大量数据，可以考虑将数据存储在磁盘或者数据库中，而不是在 map 中。

总的来说，优化 map 的 GC 需要根据具体的业务场景和数据规模来选择合适的优化方法，以达到减少 GC 的开销，提高程序性能的目的。
对于大型map，比如总数达到千万级别的map,如果键或者值中包含引用类型(string类型，结构体类型，或者任何基本类型+指针的定义 int, float 等)，那么这个MAP在垃圾回收的时候就会非常慢，GC的周期回收时间可以达到秒级。

所以对于这种map需要进行优化，把复杂的不利于GC的复杂map转化为基础类型的 map[uint64]int+外部二级索引切片的形式。比如 map[string]intercace{} 转换为 map[uint64]int+[]intercace{}的形式，变成这种形式之后，整个gc基本就不耗时了。

注意，这种做法主要适用于单次加载完后，键值对不再变化的情况。对于键值对在运行过程中还要动态增减的情况则不适合。
## 2023.8.15下午 滴滴二面
- b树和b+树区别
  　1）由于中间节点不存指针，同样大小的磁盘页可以容纳更多的节点元素，树的高度就小。（数据量相同的情况下，B+树比B树更加“矮胖”），查找起来就更快。

　　2）B+树每次查找都必须到叶子节点才能获取数据，而B树不一定，B树可以在非叶子节点上获取数据。因此B+树查找的时间更稳定。

　　3）B+树的每一个叶子节点都有指向下一个叶子节点的指针，方便范围查询和全表查询：只需要从第一个叶子节点开始顺着指针一直扫描下去即可，而B树则要对树做中序遍历。
- 场景题
  一个请求带着一千条广告，请求下游的服务，得到分数，求top1
  每一次点击产生一条消息，求一段时间后如何更新点击量
## 2023.8.22 下午 百度三面
一道简单算法题 聊天
